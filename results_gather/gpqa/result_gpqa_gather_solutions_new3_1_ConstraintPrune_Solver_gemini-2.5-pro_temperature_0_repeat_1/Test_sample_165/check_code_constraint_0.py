import re

def check_answer():
    """
    Checks the correctness of the LLM's answer for the radiative mass of a pseudo-Goldstone boson.

    The verification is based on three key principles of quantum field theory for one-loop calculations:
    1.  Dimensionality/Scaling: The mass-squared must be inversely proportional to the square of the
        symmetry-breaking scale, i.e., have a prefactor of 1/(x^2 + v^2).
    2.  Completeness: The formula must include contributions from all relevant massive particles
        in the model whose masses are generated by the VEVs.
    3.  Spin-Statistics (Signs): Contributions from bosons (spin 0, 1) must be positive, while
        contributions from fermions (spin 1/2) must be negative.
    """
    question = "Consider the extension of the Standard Model... What is the approximation of the mass of the pseudo-Goldostone boson H2 through radiative corrections?"
    
    # The final answer provided by the LLM to be checked.
    llm_answer_key = 'B'

    options = {
        'A': r"M_{h_{2}}^{2}=\frac{1}{8\pi^{2}\left(x^{2}+v^{2}\right)}\left\{ \alpha_{1}M_{h_{1}}^{4}+\alpha_{2}M_{W}^{4}+\alpha_{3}M_{Z}^{4}+\alpha_{4}M_{H^{\pm}}^{4}+\alpha_{5}M_{H^{0}}^{4}+\alpha_{6}M_{A^{0}}^{4}-\alpha_{7}\sum M_{N_{i}}^{4}\right\}",
        'B': r"M_{h_{2}}^{2}=\frac{1}{8\pi^{2}\left(x^{2}+v^{2}\right)}\left\{ \alpha_{1}M_{h_{1}}^{4}+\alpha_{2}M_{W}^{4}+\alpha_{3}M_{Z}^{4}-\alpha_{4}M_{t}^{4}+\alpha_{5}M_{H^{\pm}}^{4}+\alpha_{6}M_{H^{0}}^{4}+\alpha_{7}M_{A^{0}}^{4}-\alpha_{8}\sum M_{N_{i}}^{4}\right\}",
        'C': r"M_{h_{2}}^{2}=\frac{\left(x^{2}+v^{2}\right)}{8\pi^{2}}\left\{ \alpha_{1}M_{h_{1}}^{4}+\alpha_{2}M_{W}^{4}+\alpha_{3}M_{Z}^{4}-\alpha_{4}M_{t}^{4}+\alpha_{5}M_{H^{\pm}}^{4}+\alpha_{6}M_{H^{0}}^{4}+\alpha_{7}M_{A^{0}}^{4}-\alpha_{8}\sum M_{N_{i}}^{4}\right\}",
        'D': r"M_{h_{2}}^{2}=\frac{1}{8\pi^{2}\left(x^{2}+v^{2}\right)}\left\{ \alpha_{1}M_{h_{1}}^{4}+\alpha_{2}M_{W}^{4}+\alpha_{3}M_{Z}^{4}-\alpha_{4}M_{t}^{4}+\alpha_{5}M_{H^{\pm}}^{4}+\alpha_{6}M_{H^{0}}^{4}-\alpha_{7}\sum M_{N_{i}}^{4}\right\}"
    }

    # Define the particles that should contribute to the loop calculation
    # Their mass terms are what we search for in the formulas.
    required_bosons = ['M_{h_{1}}', 'M_{W}', 'M_{Z}', 'M_{H^{\pm}}', 'M_{H^{0}}', 'M_{A^{0}}']
    required_fermions = ['M_{t}', 'M_{N_{i}}']

    correct_option = None
    error_log = {}

    for key, formula in options.items():
        errors = []
        
        # 1. Check Dimensionality/Scaling (Prefactor)
        if not re.search(r'M_{h_{2}}\^{2}=\\frac{1}{.*\\left\(x\^{2}\+v\^{2}\\right\)}', formula):
            errors.append("Incorrect prefactor: The mass-squared should be inversely proportional to (x^2+v^2).")
        
        # Extract the content within the curly braces for sign and completeness checks
        content_match = re.search(r'\\left\{ (.*) \\right\}', formula)
        if not content_match:
            errors.append("Formula structure is unparsable (missing braces).")
            error_log[key] = errors
            continue
        
        content = content_match.group(1)

        # 2. Check Completeness (Presence of all particles)
        all_particles = required_bosons + required_fermions
        for particle in all_particles:
            if particle not in content:
                errors.append(f"Missing contribution from particle {particle}.")

        # 3. Check Signs (Spin-Statistics)
        # Add a '+' to the beginning of the content for consistent regex matching
        content_with_signs = '+' + content.replace(' ', '').replace('\\alpha', 'alpha')
        
        # Bosons should have a '+' sign
        for boson in required_bosons:
            # Regex to find the sign (+ or -) right before the boson term
            pattern = r'([+-])alpha_{\d+}' + re.escape(boson)
            match = re.search(pattern, content_with_signs)
            if match and match.group(1) == '-':
                errors.append(f"Incorrect sign for boson {boson}. Should be positive.")
        
        # Fermions should have a '-' sign
        for fermion in required_fermions:
            pattern = r'([+-])alpha_{\d+}' + re.escape(fermion)
            match = re.search(pattern, content_with_signs)
            if not match or match.group(1) == '+':
                errors.append(f"Incorrect sign for fermion {fermion}. Should be negative.")

        if not errors:
            correct_option = key
        else:
            error_log[key] = errors

    if correct_option is None:
        return "Could not identify a fully correct option based on physics principles. There might be an error in the question or all options."

    if llm_answer_key == correct_option:
        return "Correct"
    else:
        reason = f"Incorrect. The provided answer '{llm_answer_key}' is wrong.\n"
        reason += f"Reason(s) why '{llm_answer_key}' is wrong:\n"
        for e in error_log.get(llm_answer_key, ["Unknown error."]):
            reason += f"- {e}\n"
        reason += f"\nThe correct answer is '{correct_option}'. It is the only option that satisfies all physical constraints:\n"
        reason += "1. Correct scaling with the symmetry-breaking VEVs (1/(x^2+v^2)).\n"
        reason += "2. Includes contributions from all relevant particles (W, Z, t, h1, H+/-, H0, A0, Ni).\n"
        reason += "3. Correctly assigns a positive sign to boson contributions and a negative sign to fermion contributions."
        return reason

# Execute the check and print the result
print(check_answer())